// TW Snapshot
// Input SHA-256: dbc1aca726b6776c5f8d7696dfdaae62c556490a5c03bbead9fb467623b9cd3d

// Sprite1 script
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
const b0 = runtime.getOpcodeFunction("looks_say");
const b1 = stage.variables["`jEk@4|i[#Fk?(8x)AV.-my variable"];
const b2 = stage.variables["PsAI*C{QHI3*4?O8p#TM"];
const b3 = stage.variables["Go=PJS7BFXYo_qi2S:kQ"];
return function* genXYZ () {
yield* executeInCompatibilityLayer({"MESSAGE":"plan 32",}, b0, false, false, null);
if ((("" + thread.procedures["Zsimplest"]()).toLowerCase() === "It works!".toLowerCase())) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass simplest",}, b0, false, false, null);
}
if ((("" + thread.procedures["Znesting 1"]()).toLowerCase() === "42-54".toLowerCase())) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass nesting1",}, b0, false, false, null);
}
if (((+thread.procedures["Wwarp fib %s"](12) || 0) === 144)) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass fib 12",}, b0, false, false, null);
}
if (((+thread.procedures["Wfactorial %s"](12) || 0) === 479001600)) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass factorial 12",}, b0, false, false, null);
}
b1.value = (yield* thread.procedures["Zno shadowing 1 %s %s"]("f","g"));
if (compareEqual(b1.value, "")) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass default return value",}, b0, false, false, null);
}
yield* thread.procedures["Wreturn stops the script immediately"]();
if (((+b2.value || 0) === 25)) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass return stopped the script immediately",}, b0, false, false, null);
}
yield* waitThreads(startHats("event_whenbroadcastreceived", { BROADCAST_OPTION: "Test return outside of custom block" }));
if (((+b2.value || 0) === 18)) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass return worked to stop outside of custom block",}, b0, false, false, null);
}
yield* thread.procedures["Znon warp"]();
if (compareEqual(thread.procedures["Zinvalid params - reporter"](), 0)) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass invalid params reporter",}, b0, false, false, null);
}
if (compareEqual(thread.procedures["Zinvalid params - boolean"](), 0)) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass invalid params boolean",}, b0, false, false, null);
}
b3.value = 0;
b1.value = (yield* thread.procedures["Znon warp recursion should yield %s"](8));
if (((+b3.value || 0) === 4)) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass non warp recursion yields",}, b0, false, false, null);
}
b3.value = 0;
b1.value = thread.procedures["Wwarp recursion should not yield %s"](8);
if (((+b3.value || 0) === 0)) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass warp recursion does not yield",}, b0, false, false, null);
}
b1.value = (yield* thread.procedures["Zfib %s"](7));
if (((+b3.value || 0) === 12)) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass non warp fib yielded",}, b0, false, false, null);
}
yield* thread.procedures["Zrecursing yields between each %s"]("initial");
yield* thread.procedures["Zrecursing arguments eval order %s %s %s %s"]("initial","","","");
runtime.stopForTarget(target, thread);
yield* executeInCompatibilityLayer({"MESSAGE":"end",}, b0, false, false, null);
retire(); return;
}; })

// Sprite1 simplest
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
return function funXYZ_simplest () {
return "It works!";
return "";
}; })

// Sprite1 nesting 1
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
return function funXYZ_nesting_1 () {
thread.procedures["Znesting 2"]();
return (("" + thread.procedures["Znesting 3 %s %s"](6,7)) + ("" + thread.procedures["Znesting 3 %s %s"](-1,54)));
return "";
}; })

// Sprite1 warp fib %s
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
return function funXYZ_warp_fib_ (p0) {
return thread.procedures["Wfib %s"](p0);
return "";
}; })

// Sprite1 factorial %s
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
return function funXYZ_factorial_ (p0) {
if (compareGreaterThan(p0, 1)) {
return ((+p0 || 0) * (+thread.procedures["Wfactorial %s"](((+p0 || 0) - 1)) || 0));
}
return 1;
return "";
}; })

// Sprite1 no shadowing 1 %s %s
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
const b0 = runtime.getOpcodeFunction("looks_say");
const b1 = stage.variables["`jEk@4|i[#Fk?(8x)AV.-my variable"];
return function* genXYZ_no_shadowing_1__ (p0,p1) {
if (((("" + p0).toLowerCase() === "f".toLowerCase()) && (("" + p1).toLowerCase() === "g".toLowerCase()))) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass shadow check 1",}, b0, false, false, null);
}
b1.value = thread.procedures["Zno shadowing 2 %s %s"](1,2);
if (((("" + p0).toLowerCase() === "f".toLowerCase()) && (("" + p1).toLowerCase() === "g".toLowerCase()))) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass shadow check 2",}, b0, false, false, null);
}
b1.value = thread.procedures["Zno shadowing 2 %s %s"](3,4);
if (((("" + p0).toLowerCase() === "f".toLowerCase()) && (("" + p1).toLowerCase() === "g".toLowerCase()))) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass shadow check 3",}, b0, false, false, null);
}
return "";
}; })

// Sprite1 return stops the script immediately
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
const b0 = stage.variables["PsAI*C{QHI3*4?O8p#TM"];
const b1 = runtime.getOpcodeFunction("looks_say");
return function* genXYZ_return_stops_the_scr () {
b0.value = 0;
for (var a0 = 100; a0 >= 0.5; a0--) {
b0.value = ((+b0.value || 0) + 1);
if (((b0.value || 0) === 25)) {
return "stopped!";
}
if (isStuck()) yield;
}
yield* executeInCompatibilityLayer({"MESSAGE":"fail return did not stop the script immediately",}, b1, true, false, null);
return "";
}; })

// Sprite1 non warp
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
const b0 = stage.variables["Go=PJS7BFXYo_qi2S:kQ"];
const b1 = runtime.getOpcodeFunction("looks_say");
return function* genXYZ_non_warp () {
b0.value = 0;
for (var a0 = 5; a0 >= 0.5; a0--) {
thread.timer = timer();
var a1 = Math.max(0, 1000 * 0);
runtime.requestRedraw();
yield;
while (thread.timer.timeElapsed() < a1) {
yield;
}
thread.timer = null;
yield;
}
if (((+b0.value || 0) === 5)) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass non warp 1",}, b1, false, false, null);
}
if ((("" + (yield* thread.procedures["Wverify runs warp %s"]((yield* thread.procedures["Zverify runs non warp %s"]((yield* thread.procedures["Wverify runs warp %s"]("abc"))))))).toLowerCase() === "warp: non warp: warp: abc".toLowerCase())) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass non warp and warp mix",}, b1, false, false, null);
}
b0.value = 0;
for (var a2 = 5; a2 >= 0.5; a2--) {
thread.timer = timer();
var a3 = Math.max(0, 1000 * 0);
runtime.requestRedraw();
yield;
while (thread.timer.timeElapsed() < a3) {
yield;
}
thread.timer = null;
yield;
}
if (((+b0.value || 0) === 5)) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass non warp 2",}, b1, false, false, null);
}
return "";
}; })

// Sprite1 invalid params - reporter
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
return function funXYZ_invalid_params___rep () {
return 0;
return "";
}; })

// Sprite1 invalid params - boolean
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
return function funXYZ_invalid_params___boo () {
return 0;
return "";
}; })

// Sprite1 non warp recursion should yield %s
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
return function* genXYZ_non_warp_recursion_s (p0) {
if (compareGreaterThan(p0, 0)) {
return (yield* yieldThenCallGenerator(thread.procedures["Znon warp recursion should yield %s"], ((+p0 || 0) - 1)));
}
return "";
}; })

// Sprite1 warp recursion should not yield %s
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
return function funXYZ_warp_recursion_shoul (p0) {
if (compareGreaterThan(p0, 0)) {
return thread.procedures["Wwarp recursion should not yield %s"](((+p0 || 0) - 1));
}
return "";
}; })

// Sprite1 fib %s
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
return function* genXYZ_fib_ (p0) {
if (compareLessThan(p0, 2)) {
return p0;
} else {
return ((+(yield* yieldThenCallGenerator(thread.procedures["Zfib %s"], ((+p0 || 0) - 1))) || 0) + (+(yield* yieldThenCallGenerator(thread.procedures["Zfib %s"], ((+p0 || 0) - 2))) || 0));
}
return "";
}; })

// Sprite1 recursing yields between each %s
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
const b0 = stage.variables["Go=PJS7BFXYo_qi2S:kQ"];
const b1 = stage.variables["`jEk@4|i[#Fk?(8x)AV.-my variable"];
const b2 = runtime.getOpcodeFunction("looks_say");
return function* genXYZ_recursing_yields_bet (p0) {
if ((("" + p0).toLowerCase() === "initial".toLowerCase())) {
b0.value = 0;
b1.value = ((+(yield* yieldThenCallGenerator(thread.procedures["Zrecursing yields between each %s"], 1)) || 0) + (((+(yield* yieldThenCallGenerator(thread.procedures["Zrecursing yields between each %s"], 1)) || 0) + (((+(yield* yieldThenCallGenerator(thread.procedures["Zrecursing yields between each %s"], 2)) || 0) + (((+(yield* yieldThenCallGenerator(thread.procedures["Zrecursing yields between each %s"], 2)) || 0) + (((+(yield* yieldThenCallGenerator(thread.procedures["Zrecursing yields between each %s"], 3)) || 0) + (+(yield* yieldThenCallGenerator(thread.procedures["Zrecursing yields between each %s"], 3)) || 0)) || 0)) || 0)) || 0)) || 0));
if (((+b0.value || 0) === 3)) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass recursing between calls yields final",}, b2, false, false, null);
} else {
yield* executeInCompatibilityLayer({"MESSAGE":"fail recursing between calls yields final",}, b2, false, false, null);
}
} else {
if (compareEqual(b0.value, p0)) {
yield* executeInCompatibilityLayer({"MESSAGE":("pass recursing between calls yields " + ("" + p0)),}, b2, false, false, null);
} else {
yield* executeInCompatibilityLayer({"MESSAGE":("fail recursing between calls yields " + ("" + p0)),}, b2, false, false, null);
}
}
return "";
}; })

// Sprite1 recursing arguments eval order %s %s %s %s
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
const b0 = stage.variables["4HH82mPlVMOONdl(Ot*7"];
const b1 = stage.variables["Go=PJS7BFXYo_qi2S:kQ"];
const b2 = stage.variables["`jEk@4|i[#Fk?(8x)AV.-my variable"];
const b3 = runtime.getOpcodeFunction("looks_say");
return function* genXYZ_recursing_arguments_ (p0,p1,p2,p3) {
if ((("" + p0).toLowerCase() === "initial".toLowerCase())) {
b0.value = [];
b1.value = 0;
b2.value = (yield* yieldThenCallGenerator(thread.procedures["Zrecursing arguments eval order %s %s %s %s"], "child 1",(yield* yieldThenCallGenerator(thread.procedures["Zrecursing arguments eval order %s %s %s %s"], "child 2",(yield* yieldThenCallGenerator(thread.procedures["Zrecursing arguments eval order %s %s %s %s"], "child 3",(yield* yieldThenCallGenerator(thread.procedures["Zrecursing arguments eval order %s %s %s %s"], "child 4","","","")),(yield* yieldThenCallGenerator(thread.procedures["Zrecursing arguments eval order %s %s %s %s"], "child 5","","","")),(yield* yieldThenCallGenerator(thread.procedures["Zrecursing arguments eval order %s %s %s %s"], "child 6","","","")))),"","")),"",(yield* yieldThenCallGenerator(thread.procedures["Zrecursing arguments eval order %s %s %s %s"], "child 7","","",""))));
if ((("" + (b0.value[(1 | 0) - 1] ?? "")).toLowerCase() === "1/child 4".toLowerCase())) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass recurse arg order - 1",}, b3, false, false, null);
}
if ((("" + (b0.value[(2 | 0) - 1] ?? "")).toLowerCase() === "1/child 5".toLowerCase())) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass recurse arg order - 2",}, b3, false, false, null);
}
if ((("" + (b0.value[(3 | 0) - 1] ?? "")).toLowerCase() === "2/child 6".toLowerCase())) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass recurse arg order - 3",}, b3, false, false, null);
}
if ((("" + (b0.value[(4 | 0) - 1] ?? "")).toLowerCase() === "2/child 3".toLowerCase())) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass recurse arg order - 4",}, b3, false, false, null);
}
if ((("" + (b0.value[(5 | 0) - 1] ?? "")).toLowerCase() === "3/child 2".toLowerCase())) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass recurse arg order - 5",}, b3, false, false, null);
}
if ((("" + (b0.value[(6 | 0) - 1] ?? "")).toLowerCase() === "3/child 7".toLowerCase())) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass recurse arg order - 6",}, b3, false, false, null);
}
if ((("" + (b0.value[(7 | 0) - 1] ?? "")).toLowerCase() === "4/child 1".toLowerCase())) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass recurse arg order - 7",}, b3, false, false, null);
}
if ((b0.value.length === 7)) {
yield* executeInCompatibilityLayer({"MESSAGE":"pass recurse arg order - length is correct",}, b3, false, false, null);
}
} else {
b0.value.push((("" + b1.value) + ("/" + ("" + p0))));
b0._monitorUpToDate = false;
}
return "";
}; })

// Sprite1 nesting 2
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
return function funXYZ_nesting_2 () {
return "discard nesting 2";
return "";
}; })

// Sprite1 nesting 3 %s %s
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
return function funXYZ_nesting_3__ (p0,p1) {
return ((+p0 || 0) * (+p1 || 0));
return "";
}; })

// Sprite1 fib %s
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
return function funXYZ_fib_ (p0) {
if (compareLessThan(p0, 2)) {
return p0;
} else {
return ((+thread.procedures["Wfib %s"](((+p0 || 0) - 1)) || 0) + (+thread.procedures["Wfib %s"](((+p0 || 0) - 2)) || 0));
}
return "";
}; })

// Sprite1 no shadowing 2 %s %s
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
return function funXYZ_no_shadowing_2__ (p0,p1) {
return "discard shadow 2";
return "";
}; })

// Sprite1 verify runs warp %s
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
const b0 = stage.variables["Go=PJS7BFXYo_qi2S:kQ"];
const b1 = runtime.getOpcodeFunction("looks_say");
return function* genXYZ_verify_runs_warp_ (p0) {
b0.value = 0;
for (var a0 = 5; a0 >= 0.5; a0--) {
thread.timer = timer();
var a1 = Math.max(0, 1000 * 0);
runtime.requestRedraw();
while (thread.timer.timeElapsed() < a1) {
if (isStuck()) yield;
}
thread.timer = null;
if (isStuck()) yield;
}
if (!compareEqual(b0.value, 0)) {
yield* executeInCompatibilityLayer({"MESSAGE":"fail did not run warp",}, b1, true, false, null);
}
return ("warp: " + ("" + p0));
return "";
}; })

// Sprite1 verify runs non warp %s
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
const b0 = stage.variables["Go=PJS7BFXYo_qi2S:kQ"];
const b1 = runtime.getOpcodeFunction("looks_say");
return function* genXYZ_verify_runs_non_warp (p0) {
b0.value = 0;
for (var a0 = 5; a0 >= 0.5; a0--) {
thread.timer = timer();
var a1 = Math.max(0, 1000 * 0);
runtime.requestRedraw();
yield;
while (thread.timer.timeElapsed() < a1) {
yield;
}
thread.timer = null;
yield;
}
if (compareEqual(b0.value, 0)) {
yield* executeInCompatibilityLayer({"MESSAGE":"fail ran warp",}, b1, false, false, null);
}
return ("non warp: " + ("" + p0));
return "";
}; })

// Sprite1 script
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
const b0 = stage.variables["PsAI*C{QHI3*4?O8p#TM"];
return function* genXYZ () {
b0.value = 0;
while (true) {
b0.value = ((+b0.value || 0) + 1);
if (((b0.value || 0) === 18)) {
retire(); return;
}
yield;
}
retire(); return;
}; })

// Sprite1 script
(function factoryXYZ(thread) { const target = thread.target; const runtime = target.runtime; const stage = runtime.getTargetForStage();
const b0 = stage.variables["Go=PJS7BFXYo_qi2S:kQ"];
return function* genXYZ () {
b0.value = 0;
while (true) {
b0.value = ((+b0.value || 0) + 1);
thread.timer = timer();
var a0 = Math.max(0, 1000 * -1);
runtime.requestRedraw();
yield;
while (thread.timer.timeElapsed() < a0) {
yield;
}
thread.timer = null;
yield;
}
retire(); return;
}; })
